<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Blog of Ray Guo</title>
	<link rel="icon" type="image/x-icon" href="https://assets-cdn.github.com/favicon.ico">
	<link href="../../css/bootstrap.min.css" rel="stylesheet">
	<link href="../../css/template.css" rel="stylesheet">
	<link rel="stylesheet" href="../../highlight/styles/default.css">
	<script src="../../highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
	<div class="container">
	  <div class="row">
		  <div class="col-xs-12">
		    <div id="photo-header" class="text-center">
			  <div id="photo">
			    <img src="../../picture/header.png" alt="avatar"/>
			  </div>
			  <div id="text-header">
			    <h1>
				  HELLO,<br>MY NAME IS <span>XuJianGuo</span> AND THIS IS MY BLOG
				</h1>
		      </div>
          </div>
	    </div>
	  </div>
	  <div class="row">
	    <div class="col-xs-12 col-sm-9">
			
		  <div class="template">
		    <h1>同步器四大金刚</h1>
		  </div>
		  
		  <div class="template">
		    <h2>CountDownLatch</h2>
		    <p>它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。下面我们给出一个简单的例子：</p>
		    <pre><code class="java">
/*
	main线程等待其他4个线程执行完毕
*/
class CountDownLatchDemo {
	private static int size;
	private static CountDownLatch counter;
	
	static {
		size = 4;
		counter = new CountDownLatch(size);
	}
	
	static class MyThread extends Thread {
		public MyThread(String name) {
			super(name);
		}
		
		@Override
		public void run() {
			try {
				Thread.sleep(1000);
				System.out.println(getName() + " sleeping ");
				counter.countDown();
			} catch(Exception e) {
				e.printStackTrace();
			}
		}
	}
	
	public static void main(String[] args) {
		for(int i = 0; i < size; i++) {
			new MyThread("thread " + i).start();
		}
		
		System.out.println("main thread wait");
		try {
			Thread.sleep(100);
			counter.await();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("main thread over");
	}
	/*
	 result:
		main thread wait
		thread 0 sleeping 
		thread 1 sleeping 
		thread 2 sleeping 
		thread 3 sleeping 
		main thread over
	*/
}
		    </code></pre>
		    <p>CountDownLatch的源码很简单，我们贴出来分析一下：</p>
		    <pre><code class="java">
public class CountDownLatch {
    //使用AQS框架进行同步
    private static final class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 4982264981922014374L;
        //将CountDownLatch的count值作为AQS的state变量的值
        Sync(int count) {
            setState(count);
        }
	
        int getCount() {
            return getState();
        }
		
        //在获取锁的时候判断是否为是否为0，不是的话就获取锁失败，需要进入等待队列中
        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }

        //释放锁的时候如果c=0就返回失败
        protected boolean tryReleaseShared(int releases) {
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c-1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
    }

    //CountDownLatch内置的同步器，用来加锁阻塞等待
    private final Sync sync;

    //通过count值初始化一个同步器
    public CountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }

    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }

    public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }

    public void countDown() {
        sync.releaseShared(1);
    }

    public long getCount() {
        return sync.getCount();
    }

    public String toString() {
        return super.toString() + "[Count = " + sync.getCount() + "]";
    }
}
		    </code></pre>
		    <p>我们尝试用CountDownLatchDemo的例子对源码的流程进行讲解：</p>
		    <p><strong>用size去初始化counter。</strong>size在CountDownLatch最终会变成state变量的值，然后countDown方法去做减法，state的值在减到0之后就不变了。</p>
		    <p><strong>main线程调用await方法。</strong>main线程调用await方法实际上是调用sync的acquireSharedInterruptibly方法，acquireSharedInterruptibly里面主要是tryAcquireShared，这个方法的意思很简单，即使state变量为0了没，有的话我就获得锁了。而获取锁之后没有将state加1，那么其他线程来获取锁的时候，也可以获得锁，这就是我们所谓的共享锁的实现了。如果state不为0，就需要其他线程countDown了，这就是main要等待其他4个线程的主要原因了。</p>
		    <p><strong>mythread线程调用countDown方法。</strong>跟上面的差不多，最终核心的方法调用还是Sync的tryReleaseShared，如果c已经为0了，countDown就无效，不为0就用CAS操作减1.</p>
		    <p>CountDownLatch的用途还是挺多的，一个典型的例子就是手动控制事务，从数据库读取多份数据做初始化。主线程调用多个线程去数据库取数据，等所有数据都到齐了，就开始初始化。感觉有点像大佬一样，叫这个工人去盛饭，叫那个工人去盛菜，等饭菜都到齐了，才开动吃饭。</p>
		  </div>
		 	 
	    </div>
	    <div class="col-xs-12 col-sm-3">
		  <div id="template-json" class="box clearfix">
		  </div>
	    </div>
	  </div>
	</div>
    <script src="../../js/jquery-1.8.3.js"></script>
    <script src="../../js/bootstrap.min.js"></script>
    <script src="../../js/handlebars-v3.0.3.js"></script>
    <script src="../../js/show_directory.js"></script>
  </body>
</html>
