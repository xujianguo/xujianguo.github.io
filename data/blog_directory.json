{
	"python" : [
		{
			"address" : "blog/python/1.html",
			"title" : "谈谈Queue同步队列的设计",
			"outlook" : "摘要：什么是同步队列？同步队列是一个队列的数据结构，多个生产者往队列插入数据，多个消费者从队列获取数据，多个线程间互不干扰，不会产生线程安全问题。在同步队列中我们关心的问题，队列中的同步机制，在多个生产者同时添加数据的时候如何处理，在多个消费者获取数据的时候如何处理，如何提供同步机制的效率，防止过多的阻塞，各种状态下的处理算法......",
			"time" : "posted @ 2015-05-14 22:00"
		}
	],
	"javase" : [
		{
			"address" : "blog/java/1.html",
			"title" : "谈Java集合大家族",
			"outlook" : "摘要：面给出一幅关系图，实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，而点线边框的是接口，比如Collection，Iterator，List等，读者们认真阅读一下，大致了解一下各类的关系，对整个来个大概的把握.在实际项目中，什么情况下选择什么List对我们的程序的质量有着明显改变，在讨论怎么选择之前，我想有必要了解一下各种List的特点及其内部实现结构，这往往能给我们更好的判断......",
			"time" : "posted @ 2015-05-15 14:12"
		},
		{
			"address" : "blog/java/2.html",
			"title" : "从JVM层面理解volatile",
			"outlook" : "摘要：Java主存与工作内存，分析volatile之前有必要讲下Java中线程是怎么与主存进行交互的，首先看下图，这个工作内存是跟线程相关联的，就是说每个线程都是专属于自己的工作内存，工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，不能直接读取主内存中的变量。工作内存和主内存之间都有一些原子操作来实现变量的存取，从工作内存到主内存的，从主内存到工作内存的，从而实现了两者之间的交互。下面列出8种操作......",
			"time" : "posted @ 2015-05-23 23:22"
		},
		{
			"address" : "blog/java/3.html",
			"title" : "Synchronized和ReentrantLock之间的抉择",
			"outlook" : "摘要：Synchronized的核心思想就是锁住一个对象，在对象上加锁，在lockTarget方法中，synchronized锁住的是一个target的对象，在lockThis这个实例方法中，锁住的是this这个对象，在lockClass这个类方法中，锁住的是类对应的Class对象，所以在使用synchronized的时候，我们都需要显式或者隐式地指定一个对象，我们可以很清除的看到其实JVM中是使用monitorenter指令和monitorexit指令去控制加锁和解锁......",
			"time" : "posted @ 2015-05-25 20:40"
		},
		{
			"address" : "blog/java/4.html",
			"title" : "同步器四大金刚",
			"outlook" : "摘要：我们尝试用CountDownLatchDemo的例子对源码的流程进行讲解：用size去初始化counter。size在CountDownLatch最终会变成state变量的值，然后countDown方法去做减法，state的值在减到0之后就不变了,main线程调用await方法。main线程调用await方法实际上是调用sync的acquireSharedInterruptibly方法，acquireSharedInterruptibly里面主要是tryAcquireShared，这个方法的意思很简单，即使state变量为0了没......",
			"time" : "posted @ 2015-05-28 21:30"
		}
	],
	"oracle" : [
		{
			"address" : "blog/oracle/1.html",
			"title" : "Count(*)和Count(列)谁快谁慢",
			"outlook" : "摘要：没错，第一行就是count(*)的执行时间，依次是count(第1列)到count(第25列)的执行时间，我们可以发现他们是依次递增的，虽然说不是线性递增的，但是是明显的向上增长的趋势。所以，我们可以得出：count(*)的速度是最快的，列的偏移量决定了性能，列越往后，开销越大......",
			"time" : "posted @ 2015-05-17 19:32"
		},
		{
			"address" : "blog/oracle/2.html",
			"title" : "Oracle体系结构",
			"outlook" : "摘要：个人觉得面试的时候如果有人问你Oracle的时候，多多少少都会涉及到它的体系结构，就像问你JVM，就会涉及到内存模型一样。所以这里总体一下，从整体把握去叙说整个结构，理清了结构体系，对一些深入的点才能有深刻的体会......",
			"time" : "posted @ 2015-05-20 17:31"
		},
		{
			"address" : "blog/oracle/3.html",
			"title" : "通过绑定变量实现SQL共享",
			"outlook" : "摘要：Shared Pool的三大区域。SQL的解析跟Shared Pool有莫大的关系，在这里我先说一下Shared Pool里面的三大区域，有助于下面的理解。Library Cache。我们都知道SQL解析成执行计划后，会将SQL和执行计划缓存到Shared Pool中，具体就是缓存到这个Library Cache中。Free Memory。从名字我们知道这是一个未......",
		    "time" : "posted @ 2015-05-20 20:21"
		}, 
		{
			"address" : "blog/oracle/4.html",
			"title" : "世界那么大，我想跟你谈谈Buffer Cache",
			"outlook" : "摘要：Buffer Cache即数据高速缓存区，简单的说就是一块含有许多数据块的内存区域，这些数据块主要是数据文件中数据块的拷贝。Buffer Cache出现的原因跟CPU中的高速缓存一样，为了提供存取速度而出现的一种解决方案。Buffer Cache的主要功能包括下面几点：......",
		    "time" : "posted @ 2015-05-29 23:52"
		}
	]
}
